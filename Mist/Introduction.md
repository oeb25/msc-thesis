---
tags: chapter
---

%%In an age of computing being ubiquitous in all parts of society, and dependence on software systems is ever growing, the importance of their reliability and correctness goes hand in hand. Gaining confidence in the safety of a program can be a difficult task, and as developers establishing trust in our written software can be challenging and laborious, but nevertheless a crucial task. Foundationally, formal proofs can give systems mathematical guarantees, but authoring such proof is not trivial and thus needs tools to aid.%%

%%In an age of ubiquitous computing in all parts of society and dependence on software systems ever-growing, the importance of their reliability and correctness goes hand in hand. Gaining confidence in the safety of a program can be difficult, and as developers establishing trust in our written software can be challenging and laborious, but nevertheless a crucial task. Foundationally, formal proofs can give systems mathematical guarantees, but authoring such proof is not trivial and therefore needs tools to aid. Program verification is such a tool that uses automated logical reasoning to formally check the correctness of programs. However, even with such tools, the burden of verification still hinders some of its application. Thus, with an increase in the usability of verification tools, direct influence is expected on which programs are subject to verification, both from a feasibility and economic standpoint. The problem is two-fold: lower the barrier of entry to formal verification tooling and strengthen the formal foundation of program verification to allow usage in more scenarios.%%

With ubiquitous computing entering all parts of society and dependence on software systems ever-growing, the importance of their reliability and correctness goes hand in hand. Gaining confidence in the safety of a program can be difficult, and as developers establishing trust in our written software can be challenging and laborious, but nevertheless a crucial task. Foundationally, formal proofs can give systems mathematical guarantees, but authoring such proof is not trivial and therefore needs tools to assist. Program verification is such a tool that uses automated logical reasoning to formally check the correctness of programs. However, even with such tools, the burden of verification still hinders some of its application. Thus, with an increase in the usability of verification tools, direct influence is expected on which programs are subject to verification, both from a feasibility and economic standpoint. The problem is two-fold: lower the barrier of entry to formal verification through tooling and strengthen the formal foundation of program verification to broaden its usage.

Verification infrastructure sits as the basis for program verification. Viper [[@mullerViperVerificationInfrastructure2016]] is a collection of projects that allow verifying procedural and functional programs using quantified permission-based reasoning. Encoding programs for verification in such systems can give exceptional guarantees about various properties of those programs. For such tools to be efficient, they employ certain tricks to eliminate unbounded search spaces, including introducing _predicates_ as boundaries of recursive definitions. [[@parkinsonSeparationLogicAbstraction2005]] [[@mullerViperVerificationInfrastructure2016#Section~2.3]] Usage of predicates requires explicit instantiation and application, known as _fold_ and _unfold_, avoiding potentially infinite unrollings. Dealing with such foldings, however, can be time-consuming and error-prone. To mitigate this downside, we formalize a method for inferring these foldings using static analysis techniques, making it automatic and thus more ergonomic for verification.

Also in the sprit of ergonomics, language design and language tooling is core for enabling productive development environments. The Rust programming language has set a new standard for the combination of developer and runtime efficiency, in no small part thanks to its high emphasis on tooling and safety. Rust-analyzer is a model example of what is possible when building language and editor integration.

%%- Formalize place capability sets%%