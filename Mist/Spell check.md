- [x] [[Abstract-syntax tree (AST)]]
- [x] [[Abstract]]
- [x] [[Abstraction and modularity]]
- [ ] [[Acknowledgements]]
- [x] [[Analysis function and abstract semantics]]
- [x] [[Appendix – Proofs from folding analysis]]
- [ ] [[Appendix – The Mist Grammar]]
- [x] [[Appendix]]
- [x] [[Automated program verification tools]]
- [x] [[Automatic folding of isorecursive structures]]
- [x] [[Background]]
- [x] [[Case studies]]
- [x] [[Case study – Ascending sum]]
- [ ] [[Case study – Reverse sort]]
- [ ] [[Compilation stages]]
- [ ] [[Compilation structure]]
- [ ] [[Compiler improvements]]
- [ ] [[Computing solutions]]
- [ ] [[Conclusion]]
- [ ] [[Concrete-syntax tree (CST)]]
- [ ] [[Contributions]]
- [ ] [[Dafny comparison]]
- [ ] [[Definition – Analysis assignment]]
- [ ] [[Definition – Compatible]]
- [ ] [[Definition – Cut]]
- [ ] [[Definition – FIR Abstract Semantics]]
- [ ] [[Definition – FIR Memory]]
- [ ] [[Definition – FIR Program State]]
- [ ] [[Definition – FIR Semantics inference rules]]
- [ ] [[Definition – FIR Semantics]]
- [ ] [[Definition – FIR Transition]]
- [ ] [[Definition – FIR well-defined access rules]]
- [ ] [[Definition – FIR]]
- [ ] [[Definition – Foldable]]
- [ ] [[Definition – Folding tree join and meet]]
- [ ] [[Definition – Folding tree order]]
- [ ] [[Definition – Folding tree top and bottom]]
- [ ] [[Definition – Folding tree transition]]
- [ ] [[Definition – Folding tree]]
- [ ] [[Definition – Folding]]
- [ ] [[Definition – Leaves]]
- [ ] [[Definition – Locals]]
- [ ] [[Definition – Place Partial-order]]
- [ ] [[Definition – Place Prefix]]
- [ ] [[Definition – Place cover]]
- [ ] [[Definition – Place siblings]]
- [ ] [[Definition – Place]]
- [ ] [[Definition – Requires]]
- [ ] [[Definition – System of constraints]]
- [ ] [[Desugaring]]
- [ ] [[Example – Add Mist example]]
- [ ] [[Example – BTree – Complete lemma]]
- [ ] [[Example – BTree – Ghost clone and flip]]
- [ ] [[Example – BTree – Height invariant]]
- [ ] [[Example – BTree – Height]]
- [ ] [[Example – BTree – Increment]]
- [ ] [[Example – BTree – Size]]
- [ ] [[Example – BTree – Struct]]
- [ ] [[Example – BTree – Unsoundness]]
- [ ] [[Example – BTree – Values]]
- [ ] [[Example – Desugaring for loop]]
- [ ] [[Example – Folding tree]]
- [ ] [[Example – List type inference]]
- [ ] [[Example – SubFib FIR]]
- [ ] [[Example – SubFib Semantics]]
- [ ] [[Figure – A visualization of the maximally unfolded tree given by `S`]]
- [x] [[Figure – AST Fn Sample]]
- [ ] [[Figure – Ascending sum – Dafny]]
- [ ] [[Figure – Ascending sum – Mist]]
- [ ] [[Figure – Ascending sum – Viper]]
- [ ] [[Figure – Breaking invariant]]
- [ ] [[Figure – CFG with annotated analysis]]
- [ ] [[Figure – CST Example]]
- [ ] [[Figure – Complication pipeline old]]
- [ ] [[Figure – Complication pipeline]]
- [ ] [[Figure – FIR Grammar]]
- [ ] [[Figure – Folding meet join]]
- [ ] [[Figure – Folding tree folding sequence]]
- [ ] [[Figure – Folding tree requires sequence]]
- [ ] [[Figure – Loop CFG]]
- [ ] [[Figure – Modularity example]]
- [x] [[Figure – Program verification predicate]]
- [ ] [[Figure – Proptest example]]
- [ ] [[Figure – Reverse sort (Part 1) – Mist]]
- [ ] [[Figure – Reverse sort (Part 2) – Mist]]
- [ ] [[Figure – Reverse sort visualisation]]
- [ ] [[Figure – Salsa Driver example]]
- [ ] [[Figure – Salsa SourceFile example]]
- [ ] [[Figure – Snapshot example]]
- [ ] [[Figure – SumFac Program]]
- [ ] [[Final checklist]]
- [ ] [[Folding analysis]]
- [ ] [[Folding augmented programs]]
- [ ] [[Folding tree structure]]
- [ ] [[Folding-level IR (FIR)]]
- [ ] [[Future work]]
- [ ] [[High-level IR (HIR)]]
- [ ] [[Incremental computation]]
- [ ] [[Introduction]]
- [ ] [[Language server integration]]
- [ ] [[Lemma – FIR Abstract Semantics compute well-defined access]]
- [ ] [[Lemma – FIR Abstract Semantics is a monotone function]]
- [ ] [[Lemma – Fold and unfold are inverse]]
- [ ] [[Lemma – Fold and unfold commute over compatible]]
- [ ] [[Lemma – Folding tree join and meet are closed]]
- [ ] [[Lemma – Folding tree join and meet are least upper bound and greatest upper bound]]
- [ ] [[Lemma – Folding tree lattice]]
- [ ] [[Lemma – Folding tree partial order]]
- [ ] [[Lemma – Folding tree weaken cut]]
- [ ] [[Lemma – Leaves from folding]]
- [ ] [[Lemma – Meet of well-defined is well-defined]]
- [ ] [[Lemma – Meet preserves leaves]]
- [ ] [[Lemma – Requires closed-form]]
- [ ] [[Lemma – Requires commutative over compatible]]
- [ ] [[Lemma – Requires is monotone]]
- [ ] [[Lemma – Requires properties]]
- [ ] [[Limitations of current folding analysis]]
- [ ] [[Mid-level IR (MIR)]]
- [ ] [[Modes and modularity]]
- [ ] [[Monomorphization]]
- [ ] [[Normalization]]
- [ ] [[Operations on folding trees]]
- [ ] [[Ordering of folding trees]]
- [ ] [[Proof – FIR Abstract Semantics compute well-defined access]]
- [ ] [[Proof – FIR Abstract Semantics is a monotone function]]
- [ ] [[Proof – Fold and unfold commute over compatible]]
- [ ] [[Proof – Leaves from folding]]
- [ ] [[Proof – Meet of well-defined is well-defined]]
- [ ] [[Proof – Requires closed-form]]
- [ ] [[Proof – Requires commutes over compatible]]
- [ ] [[Proof – Requires is monotone]]
- [ ] [[Proof – Requires properties]]
- [ ] [[Property based testing]]
- [ ] [[Proposition – Fold and unfold commute under inverse]]
- [ ] [[Proposition – Leaves are compatible]]
- [ ] [[Proposition – Monotone the computes greatest solution]]
- [ ] [[Prusti comparison]]
- [ ] [[Red-green trees]]
- [ ] [[Related work]]
- [ ] [[Semantics]]
- [ ] [[Snapshot and property based testing]]
- [ ] [[Snapshot testing]]
- [ ] [[Subfigure – CFG with annotated analysis graph]]
- [ ] [[Syntax trees]]
- [ ] [[The Mist Compiler]]
- [ ] [[The Mist Programming Language]]
- [ ] [[Theorem – Folding analysis results in well-defined programs]]
- [ ] [[Timings]]
- [ ] [[Type checking and name resolution]]
- [ ] [[Types in Mist]]
- [ ] [[Verification code generation]]
- [ ] [[Wasm codegen backend]]
- [ ] [[Well-defined access]]
- [x] [[Why3 comparison]]
