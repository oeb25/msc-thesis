- [x] [[Abstract-syntax tree (AST)]]
- [x] [[Abstract]]
- [x] [[Abstraction and modularity]]
- [ ] [[Acknowledgements]]
- [x] [[Analysis function and abstract semantics]]
- [x] [[Appendix – Proofs from folding analysis]]
- [ ] [[Appendix – The Mist Grammar]]
- [x] [[Appendix]]
- [x] [[Automated program verification tools]]
- [x] [[Automatic folding of isorecursive structures]]
- [x] [[Background]]
- [x] [[Case studies]]
- [x] [[Case study – Ascending sum]]
- [x] [[Case study – Reverse sort]]
- [x] [[Compilation stages]]
- [x] [[Compilation structure]]
- [x] [[Compiler improvements]]
- [x] [[Computing solutions]]
- [x] [[Conclusion]]
- [x] [[Concrete-syntax tree (CST)]]
- [x] [[Contributions]]
- [x] [[Dafny comparison]]
- [x] [[Definition – Analysis assignment]]
- [x] [[Definition – Compatible]]
- [x] [[Definition – Cut]]
- [x] [[Definition – FIR Abstract Semantics]]
- [x] [[Definition – FIR Memory]]
- [x] [[Definition – FIR Program State]]
- [x] [[Definition – FIR Semantics inference rules]]
- [x] [[Definition – FIR Semantics]]
- [x] [[Definition – FIR Transition]]
- [x] [[Definition – FIR well-defined access rules]]
- [x] [[Definition – FIR]]
- [x] [[Definition – Foldable]]
- [x] [[Definition – Folding tree join and meet]]
- [x] [[Definition – Folding tree order]]
- [x] [[Definition – Folding tree top and bottom]]
- [x] [[Definition – Folding tree transition]]
- [x] [[Definition – Folding tree]]
- [x] [[Definition – Folding]]
- [x] [[Definition – Leaves]]
- [x] [[Definition – Locals]]
- [x] [[Definition – Place partial-order]]
- [x] [[Definition – Place Prefix]]
- [x] [[Definition – Place cover]]
- [x] [[Definition – Place siblings]]
- [x] [[Definition – Place]]
- [x] [[Definition – Requires]]
- [x] [[Definition – System of constraints]]
- [x] [[Desugaring]]
- [x] [[Example – Add Mist example]]
- [x] [[Example – BTree – Complete lemma]]
- [x] [[Example – BTree – Ghost clone and flip]]
- [x] [[Example – BTree – Height invariant]]
- [x] [[Example – BTree – Height]]
- [x] [[Example – BTree – Increment]]
- [x] [[Example – BTree – Size]]
- [x] [[Example – BTree – Struct]]
- [x] [[Example – BTree – Unsoundness]]
- [x] [[Example – BTree – Values]]
- [x] [[Example – Desugaring for loop]]
- [x] [[Example – Folding tree]]
- [x] [[Example – List type inference]]
- [x] [[Example – SubFib FIR]]
- [x] [[Example – SubFib Semantics]]
- [x] [[Figure – A visualization of the maximally unfolded tree given by `S`]]
- [x] [[Figure – AST Fn Sample]]
- [x] [[Figure – Ascending sum – Dafny]]
- [x] [[Figure – Ascending sum – Mist]]
- [x] [[Figure – Ascending sum – Viper]]
- [x] [[Figure – Breaking invariant]]
- [x] [[Figure – CFG with annotated analysis]]
- [x] [[Figure – CST Example]]
- [x] [[Figure – Complication pipeline old]]
- [x] [[Figure – Complication pipeline]]
- [x] [[Figure – FIR Grammar]]
- [x] [[Figure – Folding meet join]]
- [x] [[Figure – Folding tree folding sequence]]
- [x] [[Figure – Folding tree requires sequence]]
- [x] [[Figure – Loop CFG]]
- [x] [[Figure – Modularity example]]
- [x] [[Figure – Program verification predicate]]
- [x] [[Figure – Proptest example]]
- [x] [[Figure – Reverse sort (Part 1) – Mist]]
- [x] [[Figure – Reverse sort (Part 2) – Mist]]
- [x] [[Figure – Reverse sort visualisation]]
- [x] [[Figure – Salsa Driver example]]
- [x] [[Figure – Salsa SourceFile example]]
- [x] [[Figure – Snapshot example]]
- [x] [[Figure – SumFac Program]]
- [x] [[Folding analysis]]
- [x] [[Folding augmented programs]]
- [x] [[Folding tree structure]]
- [x] [[Folding-level IR (FIR)]]
- [x] [[Future work]]
- [x] [[High-level IR (HIR)]]
- [x] [[Incremental computation]]
- [ ] [[Introduction]]
- [x] [[Language server integration]]
- [x] [[Lemma – FIR Abstract Semantics compute well-defined access]]
- [x] [[Lemma – FIR Abstract Semantics is a monotone function]]
- [x] [[Lemma – Fold and unfold are inverse]]
- [x] [[Lemma – Fold and unfold commute over compatible]]
- [x] [[Lemma – Folding tree join and meet are closed]]
- [x] [[Lemma – Folding tree join and meet are least upper bound and greatest upper bound]]
- [x] [[Lemma – Folding tree lattice]]
- [x] [[Lemma – Folding tree partial order]]
- [x] [[Lemma – Folding tree weaken cut]]
- [x] [[Lemma – Leaves from folding]]
- [x] [[Lemma – Meet of well-defined is well-defined]]
- [x] [[Lemma – Meet preserves leaves]]
- [x] [[Lemma – Requires closed-form]]
- [x] [[Lemma – Requires commutative over compatible]]
- [x] [[Lemma – Requires is monotone]]
- [x] [[Lemma – Requires properties]]
- [x] [[Limitations of current folding analysis]]
- [x] [[Mid-level IR (MIR)]]
- [x] [[Modes and modularity]]
- [x] [[Normalization]]
- [x] [[Operations on folding trees]]
- [x] [[Ordering of folding trees]]
- [x] [[Proof – FIR Abstract Semantics compute well-defined access]]
- [x] [[Proof – FIR Abstract Semantics is a monotone function]]
- [x] [[Proof – Fold and unfold commute over compatible]]
- [x] [[Proof – Leaves from folding]]
- [x] [[Proof – Meet of well-defined is well-defined]]
- [x] [[Proof – Requires closed-form]]
- [x] [[Proof – Requires commutes over compatible]]
- [x] [[Proof – Requires is monotone]]
- [x] [[Proof – Requires properties]]
- [x] [[Property based testing]]
- [x] [[Proposition – Fold and unfold commute under inverse]]
- [x] [[Proposition – Leaves are compatible]]
- [x] [[Proposition – Monotone the computes greatest solution]]
- [x] [[Prusti comparison]]
- [x] [[Related work]]
- [x] [[Semantics]]
- [x] [[Snapshot and property based testing]]
- [x] [[Snapshot testing]]
- [x] [[Subfigure – CFG with annotated analysis graph]]
- [x] [[Syntax trees]]
- [x] [[The Mist Compiler]]
- [x] [[The Mist Programming Language]]
- [x] [[Theorem – Folding analysis results in well-defined programs]]
- [x] [[Type checking and name resolution]]
- [x] [[Types in Mist]]
- [x] [[Verification code generation]]
- [x] [[Wasm codegen backend]]
- [x] [[Well-defined access]]
- [x] [[Why3 comparison]]
