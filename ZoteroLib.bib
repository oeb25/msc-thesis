@inproceedings{birrellImplementingRemoteProcedure1983,
  title = {Implementing {{Remote}} Procedure Calls},
  booktitle = {Proceedings of the Ninth {{ACM}} Symposium on {{Operating}} Systems Principles  - {{SOSP}} '83},
  author = {Birrell, Andrew D. and Nelson, Bruce Jay},
  date = {1983},
  pages = {3},
  publisher = {{ACM Press}},
  location = {{Bretton Woods, New Hampshire, United States}},
  doi = {10.1145/800217.806609},
  url = {http://portal.acm.org/citation.cfm?doid=800217.806609},
  urldate = {2022-01-21},
  eventtitle = {The Ninth {{ACM}} Symposium},
  isbn = {978-0-89791-115-3},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/AMAX8AAQ/Birrell and Nelson - 1983 - Implementing Remote procedure calls.pdf}
}

@article{blackshearMoveBorrowChecker2022,
  title = {The {{Move Borrow Checker}}},
  author = {Blackshear, Sam and Mitchell, John and Nowacki, Todd and Qadeer, Shaz},
  date = {2022},
  publisher = {{arXiv}},
  doi = {10.48550/ARXIV.2205.05181},
  url = {https://arxiv.org/abs/2205.05181},
  urldate = {2023-05-12},
  abstract = {The Move language provides abstractions for programming with digital assets via a mix of value semantics and reference semantics. Ensuring memory safety in programs with references that access a shared, mutable global ledger is difficult, yet essential for the use-cases targeted by Move. The language meets this challenge with a novel memory model and a modular, intraprocedural static reference safety analysis that leverages key properties of the memory. The analysis ensures the absence of memory safety violations in all Move programs (including ones that link against untrusted code) by running as part of a load-time bytecode verification pass similar to the JVM [12] and CLR [15]. We formalize the static analysis and prove that it enjoys three desirable properties: absence of dangling references, referential transparency for immutable references, and absence of memory leaks.},
  version = {1},
  keywords = {FOS: Computer and information sciences,Programming Languages (cs.PL)},
  file = {/Users/oeb25/Zotero/storage/IGB7J3CB/Blackshear et al. - 2022 - The Move Borrow Checker.pdf}
}

@article{burleyPhysicallyBasedShading,
  title = {Physically {{Based Shading}} at {{Disney}}},
  author = {Burley, Brent},
  pages = {27},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/W35QEYND/Burley - Physically Based Shading at Disney.pdf}
}

@book{campbellIntroductionCompilerConstruction2012,
  title = {Introduction to {{Compiler Construction}} in a {{Java World}}},
  author = {Campbell, Bill and Iyer, Swami and Akbal-Delibas, Bahar},
  date = {2012-11-21},
  edition = {0},
  publisher = {{Chapman and Hall/CRC}},
  doi = {10.1201/9781482215076},
  url = {https://www.taylorfrancis.com/books/9781482215076},
  urldate = {2022-02-03},
  isbn = {978-0-429-06774-7},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/EL78K8QK/Campbell et al. - 2012 - Introduction to Compiler Construction in a Java Wo.pdf}
}

@inproceedings{comonTreeAutomataTechniques1997,
  title = {Tree Automata Techniques and Applications},
  author = {Comon, H.},
  date = {1997},
  url = {https://www.semanticscholar.org/paper/Tree-automata-techniques-and-applications-Comon/b16763765d194f440950fc6c98b7722b2537690f},
  urldate = {2023-05-30},
  abstract = {CONTENTS 7 Acknowledgments Many people gave substantial suggestions to improve the contents of this book. These are, in alphabetic order, Introduction During the past few years, several of us have been asked many times about references on finite tree automata. On one hand, this is the witness of the liveness of this field. On the other hand, it was difficult to answer. Besides several excellent survey chapters on more specific topics, there is only one monograph devoted to tree automata by Gécseg and Steinby. Unfortunately, it is now impossible to find a copy of it and a lot of work has been done on tree automata since the publication of this book. Actually using tree automata has proved to be a powerful approach to simplify and extend previously known results, and also to find new results. For instance recent works use tree automata for application in abstract interpretation using set constraints, rewriting, automated theorem proving and program verification, databases and XML schema languages. Tree automata have been designed a long time ago in the context of circuit verification. Many famous researchers contributed to this school which was headed by A. Church in the late 50's and the early 60's: B. Trakhtenbrot, Many new ideas came out of this program. For instance the connections between automata and logic. Tree automata also appeared first in this framework, following the work of Doner, Thatcher and Wright. In the 70's many new results were established concerning tree automata, which lose a bit their connections with the applications and were studied for their own. In particular, a problem was the very high complexity of decision procedures for the monadic second order logic. Applications of tree automata to program verification revived in the 80's, after the relative failure of automated deduction in this field. It is possible to verify temporal logic formulas (which are particular Monadic Second Order Formulas) on simpler (small) programs. Automata, and in particular tree automata, also appeared as an approximation of programs on which fully automated tools can be used. New results were obtained connecting properties of programs or type systems or rewrite systems with automata. Our goal is to fill in the existing gap and to provide a textbook which presents the basics of tree automata and several variants of tree automata which have been devised for applications in the aforementioned domains. We shall discuss only finite tree automata, and the …},
  file = {/Users/oeb25/Zotero/storage/4NC2VSSH/Comon - 1997 - Tree automata techniques and applications.pdf}
}

@article{dardinierVerificationPreservingInliningAutomatic2023,
  title = {Verification-{{Preserving Inlining}} in {{Automatic Separation Logic Verifiers}}},
  author = {Dardinier, Thibault and Parthasarathy, Gaurav and Müller, Peter},
  date = {2023-04-06},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {7},
  pages = {102:789--102:818},
  doi = {10.1145/3586054},
  url = {https://dl.acm.org/doi/10.1145/3586054},
  urldate = {2023-05-02},
  abstract = {Bounded verification has proved useful to detect bugs and to increase confidence in the correctness of a program. In contrast to unbounded verification, reasoning about calls via (bounded) inlining and about loops via (bounded) unrolling does not require method specifications and loop invariants and, therefore, reduces the annotation overhead to the bare minimum, namely specifications of the properties to be verified. For verifiers based on traditional program logics, verification is preserved by inlining (and unrolling): successful unbounded verification of a program w.r.t. some annotation implies successful verification of the inlined program. That is, any error detected in the inlined program reveals a true error in the original program. However, this essential property might not hold for automatic separation logic verifiers such as Caper, GRASShopper, RefinedC, Steel, VeriFast, and verifiers based on Viper. In this setting, inlining generally changes the resources owned by method executions, which may affect automatic proof search algorithms and introduce spurious errors. In this paper, we present the first technique for verification-preserving inlining in automatic separation logic verifiers. We identify a semantic condition on programs and prove in Isabelle/HOL that it ensures verification-preserving inlining for state-of-the-art automatic separation logic verifiers. We also prove a dual result: successful verification of the inlined program ensures that there are method and loop annotations that enable the verification of the original program for bounded executions. To check our semantic condition automatically, we present two approximations that can be checked syntactically and with a program verifier, respectively. We implement these checks in Viper and demonstrate that they are effective for non-trivial examples from different verifiers.},
  issue = {OOPSLA1},
  keywords = {Bounded Verification,Inlining,Loop Unrolling,Modular Verification},
  file = {/Users/oeb25/Zotero/storage/K7BY947M/Dardinier et al. - 2023 - Verification-Preserving Inlining in Automatic Sepa.pdf}
}

@article{dedonnoFoundationsEvolutionModern2019,
  title = {Foundations and {{Evolution}} of {{Modern Computing Paradigms}}: {{Cloud}}, {{IoT}}, {{Edge}}, and {{Fog}}},
  shorttitle = {Foundations and {{Evolution}} of {{Modern Computing Paradigms}}},
  author = {De Donno, Michele and Tange, Koen and Dragoni, Nicola},
  date = {2019},
  journaltitle = {IEEE Access},
  shortjournal = {IEEE Access},
  volume = {7},
  pages = {150936--150948},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2019.2947652},
  url = {https://ieeexplore.ieee.org/document/8869772/},
  urldate = {2022-01-21},
  abstract = {In the last few years, Internet of Things, Cloud computing, Edge computing, and Fog computing have gained a lot of attention in both industry and academia. However, a clear and neat definition of these computing paradigms and their correlation is hard to find in the literature. This makes it difficult for researchers new to this area to get a concrete picture of these paradigms. This work tackles this deficiency, representing a helpful resource for those who will start next. First, we show the evolution of modern computing paradigms and related research interest. Then, we address each paradigm, neatly delineating its key points and its relation with the others. Thereafter, we extensively address Fog computing, remarking its outstanding role as the glue between IoT, Cloud, and Edge computing. In the end, we briefly present open challenges and future research directions for IoT, Cloud, Edge, and Fog computing.},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/AZZ77NIY/dedonno2019.pdf.pdf;/Users/oeb25/Zotero/storage/RLUHJTYM/dedonno2019.pdf.pdf;/Users/oeb25/Zotero/storage/Y6ZQ8ZZL/De Donno et al. - 2019 - Foundations and Evolution of Modern Computing Para.pdf}
}

@online{ericlippertPersistenceFacadesRoslyn2012,
  title = {Persistence, Façades and {{Roslyn}}’s Red-Green Trees},
  author = {{Eric Lippert}},
  date = {2012-06-08T15:32:58+00:00},
  url = {https://ericlippert.com/2012/06/08/red-green-trees/},
  urldate = {2023-06-09},
  abstract = {We decided early in the Roslyn design process that the primary data structure that developers would use when analyzing code via Roslyn is the syntax tree. And thus one of the hardest parts of the e…},
  langid = {english},
  organization = {{Fabulous adventures in coding}},
  file = {/Users/oeb25/Zotero/storage/TW5UU8XA/red-green-trees.html}
}

@book{feynmanSixEasyPieces2011,
  title = {Six Easy Pieces: Essentials of Physics Explained by Its Most Brilliant Teacher},
  shorttitle = {Six Easy Pieces},
  author = {Feynman, Richard P. and Davies, Paul C. W.},
  editora = {Leighton, Robert B. and Sands, Matthew L.},
  editoratype = {collaborator},
  date = {2011},
  publisher = {{Basic Books, a member of the Perseus Books group}},
  location = {{New York}},
  isbn = {978-0-465-02527-5},
  langid = {english},
  pagetotal = {146},
  file = {/Users/oeb25/Zotero/storage/IDPTSBFL/Feynman and Davies - 2011 - Six easy pieces essentials of physics explained b.pdf}
}

@incollection{greitschusLoopInvariantsCounterexamples2017,
  title = {Loop {{Invariants}} from {{Counterexamples}}},
  booktitle = {Static {{Analysis}}},
  author = {Greitschus, Marius and Dietsch, Daniel and Podelski, Andreas},
  editor = {Ranzato, Francesco},
  date = {2017},
  volume = {10422},
  pages = {128--147},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-66706-5_7},
  url = {http://link.springer.com/10.1007/978-3-319-66706-5_7},
  urldate = {2023-05-17},
  isbn = {978-3-319-66705-8 978-3-319-66706-5}
}

@online{hodgesNotesDistributedSystems,
  title = {Notes on {{Distributed Systems}} for {{Young Bloods}} – {{Something Similar}}},
  author = {Hodges, Jeff},
  url = {https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/},
  urldate = {2022-01-21},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/IYQBD2MK/notes-on-distributed-systems-for-young-bloods.html}
}

@video{martinkleppmannCorrectnessProofsDistributed2019,
  entrysubtype = {video},
  title = {Correctness Proofs of Distributed Systems with {{Isabelle}}/{{HOL}}},
  editor = {{Martin Kleppmann}},
  editortype = {director},
  date = {2019-12-11},
  url = {https://www.youtube.com/watch?v=Uav5jWHNghY},
  urldate = {2022-02-01},
  abstract = {This is an extended version of a talk given at Strange Loop 2019 and Code Mesh London 2019. Isabelle code: https://gist.github.com/ept/b6872fc54... Slides \& more info: https://martin.kleppmann.com/2019/09/... Abstract: Testing systems is great, but tests can only explore a finite set of inputs and behaviours. Many real systems, especially distributed systems, have a potentially infinite state space. If you want to be sure that a program does the right thing in all possible situations, testing is not sufficient: you need proof. Only mathematical proof, e.g. by induction, can cover an infinite state space. Pen-and-paper proofs are well established in mathematics, but they need to be laboriously checked by hand, and humans sometimes make mistakes. Automated theorem provers and computerised proof assistants can help here. This talk introduces Isabelle/HOL, an interactive proof assistant that can be used to formally prove the correctness of algorithms. It is somewhat like a programming language and interactive console for proofs. In this talk we will explore how Isabelle can be used to analyse algorithms for distributed systems, and prove them correct. We will work through some example problems in live demos, and prove real theorems about some simple algorithms. Proof assistants still have a pretty steep learning curve, and this talk won’t be able to teach you everything, but you will get a sense of the style of reasoning, and maybe you will be tempted to try it for yourself.},
  keywords = {Automated Reasoning,Distributed Systems}
}

@online{nielsonProgramAnalysisAppetizer2020,
  title = {Program {{Analysis}} (an {{Appetizer}})},
  author = {Nielson, Flemming and Nielson, Hanne Riis},
  date = {2020-12-18},
  eprint = {2012.10086},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2012.10086},
  url = {http://arxiv.org/abs/2012.10086},
  urldate = {2023-05-04},
  abstract = {This book is an introduction to program analysis that is meant to be considerably more elementary than our advanced book Principles of Program Analysis (Springer, 2005). Rather than using flow charts as the model of programs, the book follows our introductory book Formal Methods an Appetizer (Springer, 2019) using program graphs as the model of programs. In our experience this makes the underlying ideas more accessible to our computer science and computer engineering students on the master course 02242: Program Analysis at The Technical University of Denmark. Here we have gradually replaced our use of the more elementary parts of Principles of Program Analysis with material from the current book.},
  pubstate = {preprint},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/oeb25/Zotero/storage/8AYIVBGP/Nielson and Nielson - 2020 - Program Analysis (an Appetizer).pdf;/Users/oeb25/Zotero/storage/T4VBG5DZ/2012.html}
}

@online{nipkowProgrammingProvingIsabelle,
  title = {Programming and {{Proving}} in {{Isabelle}}/{{HOL}}},
  author = {Nipkow, Tobias},
  url = {https://isabelle.in.tum.de/doc/prog-prove.pdf},
  urldate = {2022-03-10},
  keywords = {Automated Reasoning},
  file = {/Users/oeb25/Zotero/storage/4GJZ82AN/prog-prove.pdf}
}

@book{paulsonMLWorkingProgrammer1996,
  title = {{{ML}} for the {{Working Programmer}}},
  author = {Paulson, Larry C.},
  date = {1996-06-28},
  edition = {2},
  publisher = {{Cambridge University Press}},
  doi = {10.1017/CBO9780511811326},
  url = {https://www.cambridge.org/core/product/identifier/9780511811326/type/book},
  urldate = {2022-01-24},
  isbn = {978-0-521-56543-1 978-0-521-57050-3 978-0-511-81132-6},
  file = {/Users/oeb25/Zotero/storage/7V7NSRG3/Paulson - 1996 - ML for the Working Programmer.pdf}
}

@book{pierceTypesProgrammingLanguages2002,
  title = {Types and {{Programming Languages}}},
  author = {Pierce, Benjamin C.},
  date = {2002-01},
  edition = {1st},
  publisher = {{The MIT Press}},
  abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
  isbn = {978-0-262-16209-8},
  pagetotal = {645},
  file = {/Users/oeb25/Zotero/storage/E3L2EQRH/Pierce - 2002 - Types and Programming Languages.pdf}
}

@article{schwerhoffLightweightSuppoertMagic2015,
  title = {Lightweight {{Suppoert}} for {{Magic Wands}} in an {{Automatic Verifier}}},
  author = {Schwerhoff, Malte and Summers, Alexander J.},
  editora = {Boyland, John Tang},
  editoratype = {collaborator},
  date = {2015},
  publisher = {{ETH Zurich}},
  doi = {10.3929/ETHZ-B-000104710},
  url = {http://hdl.handle.net/20.500.11850/104710},
  urldate = {2023-05-11},
  langid = {english},
  keywords = {Automatic Verifiers,Implicit Dynamic Frames,Magic Wand,Separation Logic,Software Verification},
  file = {/Users/oeb25/Zotero/storage/ZEKZ36NZ/Schwerhoﬀ and Summers - Lightweight Support for Magic Wands in an Automati.pdf}
}

@online{thomasc.halesFormalProof,
  title = {Formal {{Proof}}},
  author = {{Thomas C. Hales}},
  url = {https://www.maths.ed.ac.uk/~v1ranick/papers/hales2.pdf},
  urldate = {2022-03-10},
  file = {/Users/oeb25/Zotero/storage/V6JMIWFZ/hales2.pdf}
}

@article{vansteenBriefIntroductionDistributed2016,
  title = {A Brief Introduction to Distributed Systems},
  author = {family=Steen, given=Maarten, prefix=van, useprefix=true and Tanenbaum, Andrew S.},
  date = {2016-10},
  journaltitle = {Computing},
  shortjournal = {Computing},
  volume = {98},
  number = {10},
  pages = {967--1009},
  issn = {0010-485X, 1436-5057},
  doi = {10.1007/s00607-016-0508-7},
  url = {http://link.springer.com/10.1007/s00607-016-0508-7},
  urldate = {2022-01-21},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/MN8PW5JF/van Steen and Tanenbaum - 2016 - A brief introduction to distributed systems.pdf}
}

@report{woodruffCHERIRISCCapability,
  title = {{{CHERI}}: {{A RISC}} Capability Machine for Practical Memory Safety},
  shorttitle = {{{CHERI}}},
  author = {Woodruff, Jonathan D.},
  pages = {112 pages},
  institution = {{Computer Laboratory, University of Cambridge}},
  doi = {10.48456/TR-858},
  url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-858.html},
  urldate = {2023-05-15},
  abstract = {This work presents CHERI, a practical extension of the 64-bit MIPS instruction set to support capabilities for fine-grained memory protection. Traditional paged memory protection has proved inadequate in the face of escalating security threats and proposed solutions include fine-grained protection tables (Mondrian Memory Protection) and hardware fat-pointer protection (Hardbound). These have emphasised transparent protection for C executables but have lacked flexibility and practicality. Intel's recent memory protection extensions (iMPX) attempt to adopt some of these ideas and are flexible and optional but lack the strict correctness of these proposals. Capability addressing has been the classical solution to efficient and strong memory protection but it has been thought to be incompatible with common instruction sets and also with modern program structure which uses a flat memory space with global pointers. CHERI is a fusion of capabilities with a paged flat memory producing a program-managed fat pointer capability model. This protection mechanism scales from application sandboxing to efficient byte-level memory safety with per-pointer permissions. I present an extension to the 64-bit MIPS architecture on FPGA that runs standard FreeBSD and supports self-segmenting applications in user space. Unlike other recent proposals, the CHERI implementation is open-source and of sufficient quality to support software development as well as community extension of this work. I compare with published memory safety mechanisms and demonstrate competitive performance while providing assurance and greater flexibility with simpler hardware requirements.},
  file = {/Users/oeb25/Zotero/storage/4VT3KSHI/Woodruff - CHERI A RISC capability machine for practical mem.pdf}
}
