@book{ahoCompilersPrinciplesTechniques1986,
  title = {Compilers, Principles, Techniques, and Tools},
  author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  date = {1986},
  publisher = {{Addison-Wesley Pub. Co}},
  location = {{Reading, Mass}},
  isbn = {978-0-201-10088-4},
  pagetotal = {796},
  keywords = {Compilers (Computer programs)},
  file = {/Users/oeb25/Zotero/storage/45G2MX6E/Aho et al. - 1986 - Compilers, principles, techniques, and tools.pdf}
}

@article{allenControlFlowAnalysis1970,
  title = {Control Flow Analysis},
  author = {Allen, Frances E.},
  date = {1970-07},
  journaltitle = {ACM SIGPLAN Notices},
  shortjournal = {SIGPLAN Not.},
  volume = {5},
  number = {7},
  pages = {1--19},
  issn = {0362-1340, 1558-1160},
  doi = {10.1145/390013.808479},
  url = {https://dl.acm.org/doi/10.1145/390013.808479},
  urldate = {2023-07-11},
  abstract = {Any static, global analysis of the expression and data relationships in a program requires a knowledge of the control flow of the program. Since one of the primary reasons for doing such a global analysis in a compiler is to produce optimized programs, control flow analysis has been embedded in many compilers and has been described in several papers. An early paper by Prosser [5] described the use of Boolean matrices (or, more particularly, connectivity matrices) in flow analysis. The use of “dominance” relationships in flow analysis was first introduced by Prosser and much expanded by Lowry and Medlock [6]. References [6,8,9] describe compilers which use various forms of control flow analysis for optimization. Some recent developments in the area are reported in [4] and in [7].             The underlying motivation in all the different types of control flow analysis is the need to codify the flow relationships in the program. The codification may be in connectivity matrices, in predecessor-successor tables, in dominance lists, etc. Whatever the form, the purpose is to facilitate determining what the flow relationships are; in other words to facilitate answering such questions as: is this an inner loop?, if an expression is removed from the loop where can it be correctly and profitably placed?, which variable definitions can affect this use?             In this paper the basic control flow relationships are expressed in a directed graph. Various graph constructs are then found and shown to codify interesting global relationships.},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/DCANBX2Z/allen1970.pdf.pdf}
}

@book{aptVerificationSequentialConcurrent2009,
  title = {Verification of {{Sequential}} and {{Concurrent Programs}}},
  author = {Apt, Krzysztof R. and De Boer, Frank S. and Olderog, Ernst-Rüdiger},
  editorb = {Gries, David and Schneider, Fred B.},
  editorbtype = {redactor},
  date = {2009},
  series = {Texts in {{Computer Science}}},
  publisher = {{Springer London}},
  location = {{London}},
  doi = {10.1007/978-1-84882-745-5},
  url = {http://link.springer.com/10.1007/978-1-84882-745-5},
  urldate = {2023-07-07},
  isbn = {978-1-84882-744-8 978-1-84882-745-5},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/5FPXZ9SN/Apt et al. - 2009 - Verification of Sequential and Concurrent Programs.pdf}
}

@article{astrauskasLeveragingRustTypes2019,
  title = {Leveraging Rust Types for Modular Specification and Verification},
  author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
  date = {2019-10-10},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {3},
  pages = {1--30},
  issn = {2475-1421},
  doi = {10.1145/3360573},
  url = {https://dl.acm.org/doi/10.1145/3360573},
  urldate = {2023-06-30},
  abstract = {Rust's type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Ensuring correctness properties beyond memory safety, for instance, the guaranteed absence of assertion failures or more-general functional correctness, requires static program verification. For traditional system programming languages, formal verification is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to the more-widespread verification of system software.                            In this paper, we present a novel verification technique that leverages Rust's type system to greatly simplify the specification and verification of system software written in Rust. We analyse information from the Rust compiler and synthesise a corresponding               core proof               for the program in a flavour of separation logic tailored to automation. To verify correctness properties beyond memory safety, users can annotate Rust programs with specifications at the abstraction level of Rust expressions; our technique weaves them into the core proof to verify modularly whether these specifications hold. Crucially, our proofs are constructed and checked automatically without exposing the underlying formal logic, allowing users to work exclusively at the level of abstraction of the programming language. As such, our work enables a new kind of verification tool, with the potential to impact a wide audience and allow the Rust community to benefit from state-of-the-art verification techniques. We have implemented our techniques for a subset of Rust; our evaluation on several thousand functions from widely-used Rust crates demonstrates its effectiveness.},
  issue = {OOPSLA},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/KCWD944A/Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf;/Users/oeb25/Zotero/storage/WY547PCC/astrauskas2019.pdf.pdf}
}

@article{beringerAbstractionSubsumptionModular2021,
  title = {Abstraction and Subsumption in Modular Verification of {{C}} Programs},
  author = {Beringer, Lennart and Appel, Andrew W.},
  date = {2021-10},
  journaltitle = {Formal Methods in System Design},
  shortjournal = {Form Methods Syst Des},
  volume = {58},
  number = {1-2},
  pages = {322--345},
  issn = {0925-9856, 1572-8102},
  doi = {10.1007/s10703-020-00353-1},
  url = {https://link.springer.com/10.1007/s10703-020-00353-1},
  urldate = {2023-07-07},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/2RWNU8H5/beringer2021.pdf.pdf}
}

@inproceedings{birrellImplementingRemoteProcedure1983,
  title = {Implementing {{Remote}} Procedure Calls},
  booktitle = {Proceedings of the Ninth {{ACM}} Symposium on {{Operating}} Systems Principles  - {{SOSP}} '83},
  author = {Birrell, Andrew D. and Nelson, Bruce Jay},
  date = {1983},
  pages = {3},
  publisher = {{ACM Press}},
  location = {{Bretton Woods, New Hampshire, United States}},
  doi = {10.1145/800217.806609},
  url = {http://portal.acm.org/citation.cfm?doid=800217.806609},
  urldate = {2022-01-21},
  eventtitle = {The Ninth {{ACM}} Symposium},
  isbn = {978-0-89791-115-3},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/AMAX8AAQ/Birrell and Nelson - 1983 - Implementing Remote procedure calls.pdf}
}

@article{blackshearMoveBorrowChecker2022,
  title = {The {{Move Borrow Checker}}},
  author = {Blackshear, Sam and Mitchell, John and Nowacki, Todd and Qadeer, Shaz},
  date = {2022},
  publisher = {{arXiv}},
  doi = {10.48550/ARXIV.2205.05181},
  url = {https://arxiv.org/abs/2205.05181},
  urldate = {2023-05-12},
  abstract = {The Move language provides abstractions for programming with digital assets via a mix of value semantics and reference semantics. Ensuring memory safety in programs with references that access a shared, mutable global ledger is difficult, yet essential for the use-cases targeted by Move. The language meets this challenge with a novel memory model and a modular, intraprocedural static reference safety analysis that leverages key properties of the memory. The analysis ensures the absence of memory safety violations in all Move programs (including ones that link against untrusted code) by running as part of a load-time bytecode verification pass similar to the JVM [12] and CLR [15]. We formalize the static analysis and prove that it enjoys three desirable properties: absence of dangling references, referential transparency for immutable references, and absence of memory leaks.},
  version = {1},
  keywords = {FOS: Computer and information sciences,Programming Languages (cs.PL)},
  file = {/Users/oeb25/Zotero/storage/IGB7J3CB/Blackshear et al. - 2022 - The Move Borrow Checker.pdf}
}

@inproceedings{Bornholt2021,
  title = {Using Lightweight Formal Methods to Validate a Key-Value Storage Node in {{Amazon S3}}},
  booktitle = {{{SOSP}} 2021},
  author = {Bornholt, James and Joshi, Rajeev and Astrauskas, Vytautas and Cully, Brendan and Kragl, Bernhard and Markle, Seth and Sauri, Kyle and Schleit, Drew and Slatton, Grant and Tasiran, Serdar and Geffen, Jacob Van and Warfield, Andrew},
  date = {2021},
  url = {https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3}
}

@book{bourbakiElementsMathematicsChapters2009,
  title = {Elements of Mathematics. {{Chapters}} 1/3: 2. {{Algebra}}},
  shorttitle = {Elements of Mathematics. {{Chapters}} 1/3},
  author = {Bourbaki, Nicolas},
  date = {2009},
  edition = {Softcover ed. of the 2. print., [Nachdr.]},
  publisher = {{Springer}},
  location = {{Berlin Heidelberg}},
  isbn = {978-3-540-64243-5},
  langid = {english},
  pagetotal = {708},
  file = {/Users/oeb25/Zotero/storage/GVAK3TLE/Bourbaki - 2009 - Elements of mathematics. Chapters 13 2. Algebra.pdf}
}

@article{burleyPhysicallyBasedShading,
  title = {Physically {{Based Shading}} at {{Disney}}},
  author = {Burley, Brent},
  pages = {27},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/W35QEYND/Burley - Physically Based Shading at Disney.pdf}
}

@book{campbellIntroductionCompilerConstruction2012,
  title = {Introduction to {{Compiler Construction}} in a {{Java World}}},
  author = {Campbell, Bill and Iyer, Swami and Akbal-Delibas, Bahar},
  date = {2012-11-21},
  edition = {0},
  publisher = {{Chapman and Hall/CRC}},
  doi = {10.1201/9781482215076},
  url = {https://www.taylorfrancis.com/books/9781482215076},
  urldate = {2022-02-03},
  isbn = {978-0-429-06774-7},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/EL78K8QK/Campbell et al. - 2012 - Introduction to Compiler Construction in a Java Wo.pdf}
}

@software{carboncontributersCarbon2023,
  title = {Carbon},
  author = {{Carbon contributers}},
  date = {2023-03-24T01:20:13Z},
  origdate = {2020-02-20T10:50:49Z},
  url = {https://github.com/viperproject/carbon},
  urldate = {2023-07-03},
  abstract = {Verification-condition-generation-based verifier for the Viper intermediate verification language.},
  organization = {{Viper Project}},
  keywords = {verification,verification-condition-generation,viper}
}

@inproceedings{comonTreeAutomataTechniques1997,
  title = {Tree Automata Techniques and Applications},
  author = {Comon, H.},
  date = {1997},
  url = {https://www.semanticscholar.org/paper/Tree-automata-techniques-and-applications-Comon/b16763765d194f440950fc6c98b7722b2537690f},
  urldate = {2023-05-30},
  abstract = {CONTENTS 7 Acknowledgments Many people gave substantial suggestions to improve the contents of this book. These are, in alphabetic order, Introduction During the past few years, several of us have been asked many times about references on finite tree automata. On one hand, this is the witness of the liveness of this field. On the other hand, it was difficult to answer. Besides several excellent survey chapters on more specific topics, there is only one monograph devoted to tree automata by Gécseg and Steinby. Unfortunately, it is now impossible to find a copy of it and a lot of work has been done on tree automata since the publication of this book. Actually using tree automata has proved to be a powerful approach to simplify and extend previously known results, and also to find new results. For instance recent works use tree automata for application in abstract interpretation using set constraints, rewriting, automated theorem proving and program verification, databases and XML schema languages. Tree automata have been designed a long time ago in the context of circuit verification. Many famous researchers contributed to this school which was headed by A. Church in the late 50's and the early 60's: B. Trakhtenbrot, Many new ideas came out of this program. For instance the connections between automata and logic. Tree automata also appeared first in this framework, following the work of Doner, Thatcher and Wright. In the 70's many new results were established concerning tree automata, which lose a bit their connections with the applications and were studied for their own. In particular, a problem was the very high complexity of decision procedures for the monadic second order logic. Applications of tree automata to program verification revived in the 80's, after the relative failure of automated deduction in this field. It is possible to verify temporal logic formulas (which are particular Monadic Second Order Formulas) on simpler (small) programs. Automata, and in particular tree automata, also appeared as an approximation of programs on which fully automated tools can be used. New results were obtained connecting properties of programs or type systems or rewrite systems with automata. Our goal is to fill in the existing gap and to provide a textbook which presents the basics of tree automata and several variants of tree automata which have been devised for applications in the aforementioned domains. We shall discuss only finite tree automata, and the …},
  file = {/Users/oeb25/Zotero/storage/4NC2VSSH/Comon - 1997 - Tree automata techniques and applications.pdf}
}

@article{dardinierVerificationPreservingInliningAutomatic2023,
  title = {Verification-{{Preserving Inlining}} in {{Automatic Separation Logic Verifiers}}},
  author = {Dardinier, Thibault and Parthasarathy, Gaurav and Müller, Peter},
  date = {2023-04-06},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {7},
  pages = {102:789--102:818},
  doi = {10.1145/3586054},
  url = {https://dl.acm.org/doi/10.1145/3586054},
  urldate = {2023-05-02},
  abstract = {Bounded verification has proved useful to detect bugs and to increase confidence in the correctness of a program. In contrast to unbounded verification, reasoning about calls via (bounded) inlining and about loops via (bounded) unrolling does not require method specifications and loop invariants and, therefore, reduces the annotation overhead to the bare minimum, namely specifications of the properties to be verified. For verifiers based on traditional program logics, verification is preserved by inlining (and unrolling): successful unbounded verification of a program w.r.t. some annotation implies successful verification of the inlined program. That is, any error detected in the inlined program reveals a true error in the original program. However, this essential property might not hold for automatic separation logic verifiers such as Caper, GRASShopper, RefinedC, Steel, VeriFast, and verifiers based on Viper. In this setting, inlining generally changes the resources owned by method executions, which may affect automatic proof search algorithms and introduce spurious errors. In this paper, we present the first technique for verification-preserving inlining in automatic separation logic verifiers. We identify a semantic condition on programs and prove in Isabelle/HOL that it ensures verification-preserving inlining for state-of-the-art automatic separation logic verifiers. We also prove a dual result: successful verification of the inlined program ensures that there are method and loop annotations that enable the verification of the original program for bounded executions. To check our semantic condition automatically, we present two approximations that can be checked syntactically and with a program verifier, respectively. We implement these checks in Viper and demonstrate that they are effective for non-trivial examples from different verifiers.},
  issue = {OOPSLA1},
  keywords = {Bounded Verification,Inlining,Loop Unrolling,Modular Verification},
  file = {/Users/oeb25/Zotero/storage/K7BY947M/Dardinier et al. - 2023 - Verification-Preserving Inlining in Automatic Sepa.pdf}
}

@article{dedonnoFoundationsEvolutionModern2019,
  title = {Foundations and {{Evolution}} of {{Modern Computing Paradigms}}: {{Cloud}}, {{IoT}}, {{Edge}}, and {{Fog}}},
  shorttitle = {Foundations and {{Evolution}} of {{Modern Computing Paradigms}}},
  author = {De Donno, Michele and Tange, Koen and Dragoni, Nicola},
  date = {2019},
  journaltitle = {IEEE Access},
  shortjournal = {IEEE Access},
  volume = {7},
  pages = {150936--150948},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2019.2947652},
  url = {https://ieeexplore.ieee.org/document/8869772/},
  urldate = {2022-01-21},
  abstract = {In the last few years, Internet of Things, Cloud computing, Edge computing, and Fog computing have gained a lot of attention in both industry and academia. However, a clear and neat definition of these computing paradigms and their correlation is hard to find in the literature. This makes it difficult for researchers new to this area to get a concrete picture of these paradigms. This work tackles this deficiency, representing a helpful resource for those who will start next. First, we show the evolution of modern computing paradigms and related research interest. Then, we address each paradigm, neatly delineating its key points and its relation with the others. Thereafter, we extensively address Fog computing, remarking its outstanding role as the glue between IoT, Cloud, and Edge computing. In the end, we briefly present open challenges and future research directions for IoT, Cloud, Edge, and Fog computing.},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/AZZ77NIY/dedonno2019.pdf.pdf;/Users/oeb25/Zotero/storage/RLUHJTYM/dedonno2019.pdf.pdf;/Users/oeb25/Zotero/storage/Y6ZQ8ZZL/De Donno et al. - 2019 - Foundations and Evolution of Modern Computing Para.pdf}
}

@online{ericlippertPersistenceFacadesRoslyn2012,
  title = {Persistence, Façades and {{Roslyn}}’s Red-Green Trees},
  author = {{Eric Lippert}},
  date = {2012-06-08T15:32:58+00:00},
  url = {https://ericlippert.com/2012/06/08/red-green-trees/},
  urldate = {2023-06-09},
  abstract = {We decided early in the Roslyn design process that the primary data structure that developers would use when analyzing code via Roslyn is the syntax tree. And thus one of the hardest parts of the e…},
  langid = {english},
  organization = {{Fabulous adventures in coding}},
  file = {/Users/oeb25/Zotero/storage/TW5UU8XA/red-green-trees.html}
}

@book{feynmanSixEasyPieces2011,
  title = {Six Easy Pieces: Essentials of Physics Explained by Its Most Brilliant Teacher},
  shorttitle = {Six Easy Pieces},
  author = {Feynman, Richard P. and Davies, Paul C. W.},
  editora = {Leighton, Robert B. and Sands, Matthew L.},
  editoratype = {collaborator},
  date = {2011},
  publisher = {{Basic Books, a member of the Perseus Books group}},
  location = {{New York}},
  isbn = {978-0-465-02527-5},
  langid = {english},
  pagetotal = {146},
  file = {/Users/oeb25/Zotero/storage/IDPTSBFL/Feynman and Davies - 2011 - Six easy pieces essentials of physics explained b.pdf}
}

@book{gratzerGeneralLatticeTheory2003,
  title = {General Lattice Theory},
  author = {Grätzer, George and Davey, B. A. and Davey, Brian A.},
  date = {2003},
  edition = {2. ed},
  publisher = {{Birkhäuser}},
  location = {{Basel Berlin}},
  isbn = {978-3-7643-6996-5},
  langid = {english},
  pagetotal = {663},
  file = {/Users/oeb25/Zotero/storage/S9NPL7N8/general-lattice-theory-grätzer-george-2nd-2007-2nd--annas-archive.pdf;/Users/oeb25/Zotero/storage/UI7D2ULC/Grätzer et al. - 2003 - General lattice theory.pdf}
}

@incollection{greitschusLoopInvariantsCounterexamples2017,
  title = {Loop {{Invariants}} from {{Counterexamples}}},
  booktitle = {Static {{Analysis}}},
  author = {Greitschus, Marius and Dietsch, Daniel and Podelski, Andreas},
  editor = {Ranzato, Francesco},
  date = {2017},
  volume = {10422},
  pages = {128--147},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-66706-5_7},
  url = {http://link.springer.com/10.1007/978-3-319-66706-5_7},
  urldate = {2023-05-17},
  isbn = {978-3-319-66705-8 978-3-319-66706-5}
}

@book{hachtelLogicSynthesisVerification1996,
  title = {Logic Synthesis and Verification Algorithms},
  author = {Hachtel, Gary D. and Somenzi, Fabio},
  date = {1996},
  publisher = {{Kluwer Academic Publishers}},
  location = {{Boston}},
  isbn = {978-0-7923-9746-5},
  pagetotal = {564},
  keywords = {Computer-aided design,Data processing,Integrated circuits,Logic design,Verification,Very large scale integration Design Data processing}
}

@inproceedings{hammerAdaptonComposableDemanddriven2014,
  title = {Adapton: Composable, Demand-Driven Incremental Computation},
  shorttitle = {Adapton},
  booktitle = {Proceedings of the 35th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Hammer, Matthew A. and Phang, Khoo Yit and Hicks, Michael and Foster, Jeffrey S.},
  date = {2014-06-09},
  pages = {156--166},
  publisher = {{ACM}},
  location = {{Edinburgh United Kingdom}},
  doi = {10.1145/2594291.2594324},
  url = {https://dl.acm.org/doi/10.1145/2594291.2594324},
  urldate = {2023-07-03},
  abstract = {Many researchers have proposed programming languages that support incremental computation (IC), which allows programs to be efficiently re-executed after a small change to the input. However, existing implementations of such languages have two important drawbacks. First, recomputation is oblivious to specific demands on the program output; that is, if a program input changes, all dependencies will be recomputed, even if an observer no longer requires certain outputs. Second, programs are made incremental as a unit, with little or no support for reusing results outside of their original context, e.g., when reordered.},
  eventtitle = {{{PLDI}} '14: {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  isbn = {978-1-4503-2784-8},
  langid = {english},
  keywords = {incremental},
  file = {/Users/oeb25/Zotero/storage/N3HHLRDM/Hammer et al. - 2014 - Adapton composable, demand-driven incremental com.pdf;/Users/oeb25/Zotero/storage/NQ4EEQG8/hammer2013.pdf.pdf}
}

@article{hindleyPrincipalTypeSchemeObject1969,
  title = {The {{Principal Type-Scheme}} of an {{Object}} in {{Combinatory Logic}}},
  author = {Hindley, R.},
  date = {1969-12},
  journaltitle = {Transactions of the American Mathematical Society},
  shortjournal = {Transactions of the American Mathematical Society},
  volume = {146},
  eprint = {1995158},
  eprinttype = {jstor},
  pages = {29},
  issn = {00029947},
  doi = {10.2307/1995158},
  url = {https://www.jstor.org/stable/1995158?origin=crossref},
  urldate = {2023-07-06},
  file = {/Users/oeb25/Zotero/storage/8I6VHCRR/hindley1969.pdf.pdf}
}

@online{hodgesNotesDistributedSystems,
  title = {Notes on {{Distributed Systems}} for {{Young Bloods}} – {{Something Similar}}},
  author = {Hodges, Jeff},
  url = {https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/},
  urldate = {2022-01-21},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/IYQBD2MK/notes-on-distributed-systems-for-young-bloods.html}
}

@online{kladovResilientLLParsing,
  title = {Resilient {{LL Parsing Tutorial}}},
  author = {Kladov, Alex},
  url = {https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html},
  urldate = {2023-07-02},
  file = {/Users/oeb25/Zotero/storage/LE4C3HJC/resilient-ll-parsing-tutorial.html}
}

@online{LatticeTheory,
  title = {Lattice {{Theory}}},
  url = {https://bookstore.ams.org/coll-25/},
  urldate = {2023-06-20},
  file = {/Users/oeb25/Zotero/storage/SZ6ERJ5D/coll-25.html}
}

@incollection{leinoDafnyAutomaticProgram2010,
  title = {Dafny: {{An Automatic Program Verifier}} for {{Functional Correctness}}},
  shorttitle = {Dafny},
  booktitle = {Logic for {{Programming}}, {{Artificial Intelligence}}, and {{Reasoning}}},
  author = {Leino, K. Rustan M.},
  editor = {Clarke, Edmund M. and Voronkov, Andrei},
  date = {2010},
  volume = {6355},
  pages = {348--370},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-17511-4_20},
  url = {http://link.springer.com/10.1007/978-3-642-17511-4_20},
  urldate = {2023-07-09},
  isbn = {978-3-642-17510-7 978-3-642-17511-4}
}

@software{lsp,
  title = {Language {{Server Protocol}}},
  author = {{Dirk Bäumer} and {Microsoft}},
  url = {https://microsoft.github.io/language-server-protocol/},
  urldate = {2023-07-10},
  abstract = {Adding features like auto complete, go to definition, or documentation on hover for a programming language takes significant effort. Traditionally this work had to be repeated for each development tool, as each tool provides different APIs for implementing the same feature. A Language Server is meant to provide the language-specific smarts and communicate with development tools over a protocol that enables inter-process communication. The idea behind the Language Server Protocol (LSP) is to standardize the protocol for how such servers and development tools communicate. This way, a single Language Server can be re-used in multiple development tools, which in turn can support multiple languages with minimal effort. LSP is a win for both language providers and tooling vendors!},
  file = {/Users/oeb25/Zotero/storage/3MT2TIG2/language-server-protocol.html}
}

@thesis{maissenAddingAlgebraicData2022,
  title = {Adding {{Algebraic Data Types}} to a {{Veriﬁcation Language}}},
  author = {Maissen, Alessandro},
  date = {2022},
  institution = {{ETH Zurich}},
  url = {https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Education/Theses/Alessandro%20Maissen_PW_Report.pdf},
  urldate = {2023-07-07},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/AQV2HM6Z/Maissen - Adding Algebraic Data Types to a Veriﬁcation Langu.pdf}
}

@video{martinkleppmannCorrectnessProofsDistributed2019,
  entrysubtype = {video},
  title = {Correctness Proofs of Distributed Systems with {{Isabelle}}/{{HOL}}},
  editor = {{Martin Kleppmann}},
  editortype = {director},
  date = {2019-12-11},
  url = {https://www.youtube.com/watch?v=Uav5jWHNghY},
  urldate = {2022-02-01},
  abstract = {This is an extended version of a talk given at Strange Loop 2019 and Code Mesh London 2019. Isabelle code: https://gist.github.com/ept/b6872fc54... Slides \& more info: https://martin.kleppmann.com/2019/09/... Abstract: Testing systems is great, but tests can only explore a finite set of inputs and behaviours. Many real systems, especially distributed systems, have a potentially infinite state space. If you want to be sure that a program does the right thing in all possible situations, testing is not sufficient: you need proof. Only mathematical proof, e.g. by induction, can cover an infinite state space. Pen-and-paper proofs are well established in mathematics, but they need to be laboriously checked by hand, and humans sometimes make mistakes. Automated theorem provers and computerised proof assistants can help here. This talk introduces Isabelle/HOL, an interactive proof assistant that can be used to formally prove the correctness of algorithms. It is somewhat like a programming language and interactive console for proofs. In this talk we will explore how Isabelle can be used to analyse algorithms for distributed systems, and prove them correct. We will work through some example problems in live demos, and prove real theorems about some simple algorithms. Proof assistants still have a pretty steep learning curve, and this talk won’t be able to teach you everything, but you will get a sense of the style of reasoning, and maybe you will be tempted to try it for yourself.},
  keywords = {Automated Reasoning,Distributed Systems}
}

@online{matsakisIntroducingMIRRust2016,
  title = {Introducing {{MIR}} | {{Rust Blog}}},
  author = {Matsakis, Niko},
  date = {2016-04-19},
  url = {https://blog.rust-lang.org/2016/04/19/MIR.html},
  urldate = {2023-07-11},
  abstract = {Empowering everyone to build reliable and efficient software.},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/SQHQ6HZG/MIR.html}
}

@software{matsakisSalsa2023,
  title = {Salsa},
  author = {Matsakis, Niko and Kladov, Alex and {Salsa contributers}},
  date = {2023-06-30T10:28:43Z},
  origdate = {2018-09-28T14:56:12Z},
  url = {https://github.com/salsa-rs/salsa},
  urldate = {2023-07-02},
  abstract = {A generic framework for on-demand, incrementalized computation. Inspired by adapton, glimmer, and rustc's query system.},
  organization = {{salsa}},
  keywords = {incremental,rust}
}

@article{midtgaardControlflowAnalysisFunctional2012,
  title = {Control-Flow Analysis of Functional Programs},
  author = {Midtgaard, Jan},
  date = {2012-06},
  journaltitle = {ACM Computing Surveys},
  shortjournal = {ACM Comput. Surv.},
  volume = {44},
  number = {3},
  pages = {1--33},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/2187671.2187672},
  url = {https://dl.acm.org/doi/10.1145/2187671.2187672},
  urldate = {2023-07-11},
  abstract = {We present a survey of control-flow analysis of functional programs, which has been the subject of extensive investigation throughout the past 30 years. Analyses of the control flow of functional programs have been formulated in multiple settings and have led to many different approximations, starting with the seminal works of Jones, Shivers, and Sestoft. In this article, we survey control-flow analysis of functional programs by structuring the multitude of formulations and approximations and comparing them.},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/9J857BT6/midtgaard2012.pdf.pdf;/Users/oeb25/Zotero/storage/D3URBLCX/Midtgaard - 2012 - Control-flow analysis of functional programs.pdf}
}

@article{milnerTheoryTypePolymorphism1978,
  title = {A Theory of Type Polymorphism in Programming},
  author = {Milner, Robin},
  date = {1978-12},
  journaltitle = {Journal of Computer and System Sciences},
  shortjournal = {Journal of Computer and System Sciences},
  volume = {17},
  number = {3},
  pages = {348--375},
  issn = {00220000},
  doi = {10.1016/0022-0000(78)90014-4},
  url = {https://linkinghub.elsevier.com/retrieve/pii/0022000078900144},
  urldate = {2023-07-06},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/8QAT56KW/Milner - 1978 - A theory of type polymorphism in programming.pdf;/Users/oeb25/Zotero/storage/BTJFE67W/milner1978.pdf.pdf}
}

@online{minskyTestingExpectations2015,
  title = {Testing with Expectations},
  author = {Minsky, Yaron},
  date = {2015-12-02},
  url = {https://blog.janestreet.com/testing-with-expectations/},
  urldate = {2023-07-10},
  abstract = {Testing is important, and it’s hard to get people to do as much of it as theyshould. Testing tools matter because the smoother the process is, the more tests...},
  organization = {{Jane Street Tech Blog}},
  file = {/Users/oeb25/Zotero/storage/9HIN8VAM/testing-with-expectations.html}
}

@article{mitchellAbstractTypesExistential1988,
  title = {Abstract Types Have Existential Type},
  author = {Mitchell, John C. and Plotkin, Gordon D.},
  date = {1988-07},
  journaltitle = {ACM Transactions on Programming Languages and Systems},
  shortjournal = {ACM Trans. Program. Lang. Syst.},
  volume = {10},
  number = {3},
  pages = {470--502},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/44501.45065},
  url = {https://dl.acm.org/doi/10.1145/44501.45065},
  urldate = {2023-07-07},
  abstract = {Abstract data type declarations appear in typed programming languages like Ada, Alphard, CLU and ML. This form of declaration binds a list of identifiers to a type with associated operations, a composite “value” we call a               data algebra               . We use a second-order typed lambda calculus SOL to show how data algebras may be given types, passed as parameters, and returned as results of function calls. In the process, we discuss the semantics of abstract data type declarations and review a connection between typed programming languages and constructive logic.},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/6PK8TB6Z/mitchell1988.pdf.pdf;/Users/oeb25/Zotero/storage/E52VGIUC/mitchell1988.pdf.pdf;/Users/oeb25/Zotero/storage/WBEB2PLQ/Mitchell and Plotkin - 1988 - Abstract types have existential type.pdf}
}

@incollection{mullerViperVerificationInfrastructure2016,
  title = {Viper: {{A Verification Infrastructure}} for {{Permission-Based Reasoning}}},
  shorttitle = {Viper},
  booktitle = {Verification, {{Model Checking}}, and {{Abstract Interpretation}}},
  author = {Müller, Peter and Schwerhoff, Malte and Summers, Alexander J.},
  editor = {Jobstmann, Barbara and Leino, K. Rustan M.},
  date = {2016},
  volume = {9583},
  pages = {41--62},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-49122-5_2},
  url = {http://link.springer.com/10.1007/978-3-662-49122-5_2},
  urldate = {2023-07-03},
  isbn = {978-3-662-49121-8 978-3-662-49122-5},
  file = {/Users/oeb25/Zotero/storage/F9FLPE27/Müller et al. - 2016 - Viper A Verification Infrastructure for Permissio.pdf}
}

@book{nielsonPrinciplesProgramAnalysis1999,
  title = {Principles of {{Program Analysis}}},
  author = {Nielson, Flemming and Nielson, Hanne Riis and Hankin, Chris},
  date = {1999},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-03811-6},
  url = {http://link.springer.com/10.1007/978-3-662-03811-6},
  urldate = {2023-07-11},
  isbn = {978-3-642-08474-4 978-3-662-03811-6},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/P6FLTPNA/Nielson et al. - 1999 - Principles of Program Analysis.pdf}
}

@online{nielsonProgramAnalysisAppetizer2020,
  title = {Program {{Analysis}} (an {{Appetizer}})},
  author = {Nielson, Flemming and Nielson, Hanne Riis},
  date = {2020-12-18},
  eprint = {2012.10086},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2012.10086},
  url = {http://arxiv.org/abs/2012.10086},
  urldate = {2023-05-04},
  abstract = {This book is an introduction to program analysis that is meant to be considerably more elementary than our advanced book Principles of Program Analysis (Springer, 2005). Rather than using flow charts as the model of programs, the book follows our introductory book Formal Methods an Appetizer (Springer, 2019) using program graphs as the model of programs. In our experience this makes the underlying ideas more accessible to our computer science and computer engineering students on the master course 02242: Program Analysis at The Technical University of Denmark. Here we have gradually replaced our use of the more elementary parts of Principles of Program Analysis with material from the current book.},
  pubstate = {preprint},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/oeb25/Zotero/storage/8AYIVBGP/Nielson and Nielson - 2020 - Program Analysis (an Appetizer).pdf;/Users/oeb25/Zotero/storage/T4VBG5DZ/2012.html}
}

@online{nipkowProgrammingProvingIsabelle,
  title = {Programming and {{Proving}} in {{Isabelle}}/{{HOL}}},
  author = {Nipkow, Tobias},
  url = {https://isabelle.in.tum.de/doc/prog-prove.pdf},
  urldate = {2022-03-10},
  keywords = {Automated Reasoning},
  file = {/Users/oeb25/Zotero/storage/4GJZ82AN/prog-prove.pdf}
}

@inproceedings{parkinsonSeparationLogicAbstraction2005,
  title = {Separation Logic and Abstraction},
  booktitle = {Proceedings of the 32nd {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author = {Parkinson, Matthew and Bierman, Gavin},
  date = {2005-01-12},
  pages = {247--258},
  publisher = {{ACM}},
  location = {{Long Beach California USA}},
  doi = {10.1145/1040305.1040326},
  url = {https://dl.acm.org/doi/10.1145/1040305.1040326},
  urldate = {2023-07-07},
  eventtitle = {{{POPL05}}: {{The}} 32nd {{Annual ACM SIGPLAN-SIGACT Symposium}} on {{Principles}} of {{Programming Languages}} 2005},
  isbn = {978-1-58113-830-6},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/U7KEPMFW/parkinson2005.pdf.pdf}
}

@book{paulsonMLWorkingProgrammer1996,
  title = {{{ML}} for the {{Working Programmer}}},
  author = {Paulson, Larry C.},
  date = {1996-06-28},
  edition = {2},
  publisher = {{Cambridge University Press}},
  doi = {10.1017/CBO9780511811326},
  url = {https://www.cambridge.org/core/product/identifier/9780511811326/type/book},
  urldate = {2022-01-24},
  isbn = {978-0-521-56543-1 978-0-521-57050-3 978-0-511-81132-6},
  file = {/Users/oeb25/Zotero/storage/7V7NSRG3/Paulson - 1996 - ML for the Working Programmer.pdf}
}

@book{pierceTypesProgrammingLanguages2002,
  title = {Types and {{Programming Languages}}},
  author = {Pierce, Benjamin C.},
  date = {2002-01},
  edition = {1},
  publisher = {{The MIT Press}},
  abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
  isbn = {978-0-262-16209-8},
  pagetotal = {645},
  file = {/Users/oeb25/Zotero/storage/E3L2EQRH/Pierce - 2002 - Types and Programming Languages.pdf}
}

@online{Proptest,
  title = {Proptest-Rs/Proptest: {{Hypothesis-like}} Property Testing for {{Rust}}},
  author = {{Proptest Contributers}},
  url = {https://github.com/proptest-rs/proptest},
  urldate = {2023-07-04},
  file = {/Users/oeb25/Zotero/storage/BLV5G4DH/proptest.html}
}

@article{raskDecouplingCoreAnalysis2021,
  title = {Decoupling of {{Core Analysis Support}} for {{Specification Languages}} from {{User Interfaces}} in {{Integrated Development Environments}}},
  author = {Rask, Jonas Kjær and Madsen, Frederik Palludan},
  date = {2021},
  publisher = {{Unpublished}},
  doi = {10.13140/RG.2.2.21889.99686},
  url = {http://rgdoi.net/10.13140/RG.2.2.21889.99686},
  urldate = {2023-07-10},
  langid = {english}
}

@article{raskSpecificationLanguageServer2021,
  title = {The {{Specification Language Server Protocol}}: {{A Proposal}} for {{Standardised LSP Extensions}}},
  shorttitle = {The {{Specification Language Server Protocol}}},
  author = {Rask, Jonas Kjær and Madsen, Frederik Palludan and Battle, Nick and Macedo, Hugo Daniel and Larsen, Peter Gorm},
  date = {2021-08-06},
  journaltitle = {Electronic Proceedings in Theoretical Computer Science},
  shortjournal = {Electron. Proc. Theor. Comput. Sci.},
  volume = {338},
  eprint = {2108.02961},
  eprinttype = {arxiv},
  eprintclass = {cs},
  pages = {3--18},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.338.3},
  url = {http://arxiv.org/abs/2108.02961},
  urldate = {2023-07-10},
  abstract = {The Language Server Protocol (LSP) changed the field of Integrated Development Environments(IDEs), as it decouples core (programming) language features functionality from editor smarts, thus lowering the effort required to extend an IDE to support a language. The concept is a success and has been adopted by several programming languages and beyond. This is shown by the emergence of several LSP implementations for the many programming and specification languages (languages with a focus on modelling, reasoning, or proofs). However, for such languages LSP has been ad-hocly extended with the additional functionalities that are typically not found for programming languages and thus not supported in LSP. This foils the original LSP decoupling goal, because the move towards a new IDE requires yet another re-implementation of the ad-hoc LSP extension. In this paper we contribute with a conservative extension of LSP providing a first proposal towards a standard protocol decoupling the support of specification languages from the IDE. We hope our research attracts the larger community and motivates the need of a joint task force leading to a standardised LSP extension serving the particular needs of specification languages.},
  keywords = {Computer Science - Software Engineering},
  file = {/Users/oeb25/Zotero/storage/TBDCEKWU/Rask et al. - 2021 - The Specification Language Server Protocol A Prop.pdf;/Users/oeb25/Zotero/storage/6K8T98LP/2108.html}
}

@software{ronacherMitsuhikoInsta2023,
  title = {Mitsuhiko/Insta},
  author = {Ronacher, Armin},
  date = {2023-06-30T22:38:28Z},
  origdate = {2019-01-13T22:25:41Z},
  url = {https://github.com/mitsuhiko/insta},
  urldate = {2023-07-04},
  abstract = {A snapshot testing library for rust},
  keywords = {rust,snapshot-tests,vscode-extension}
}

@software{RustAnalyzerArchitecture2023,
  title = {Rust-Lang/Rust-Analyzer – {{Architecture}}},
  author = {{The rust-analyzer Project Developers}},
  date = {2023-07-03T19:17:27Z},
  origdate = {2017-12-21T19:24:42Z},
  url = {https://github.com/rust-lang/rust-analyzer/blob/0dd2c0d8d3f6aa8ec1079270d65d2ecf1c64ce78/docs/dev/architecture.md},
  urldate = {2023-07-04},
  abstract = {A Rust compiler front-end for IDEs},
  organization = {{The Rust Programming Language}},
  keywords = {rust}
}

@software{RustCompilerDevelopment2018,
  title = {Rust Compiler Development Guide (Rustc-Dev-Guide)},
  author = {{The Rust Project Developers}},
  date = {2018-01},
  url = {https://github.com/rust-lang/rustc-dev-guide},
  keywords = {rust}
}

@thesis{schwerhoffAdvancingAutomatedPermissionBased2016,
  title = {Advancing {{Automated}}, {{Permission-Based Program Verification Using Symbolic Execution}}},
  author = {Schwerhoff, Malte H.},
  editora = {{Jacobs, Bart} and {Müller, Peter}},
  editoratype = {collaborator},
  date = {2016},
  pages = {229 p.},
  institution = {{ETH Zurich}},
  doi = {10.3929/ETHZ-A-010835519},
  url = {http://hdl.handle.net/20.500.11850/127711},
  urldate = {2023-07-03},
  langid = {english},
  keywords = {CONCURRENT PROGRAMMING + DISTRIBUTED PROGRAMMING + PARALLEL PROGRAMMING (PROGRAMMING METHODS),CORRECTNESS (THEORY OF PROGRAMMING),{Data processing, computer science},info:eu-repo/classification/ddc/004,KORREKTHEIT (THEORIE DER PROGRAMMIERUNG),VERIFICATION (SOFTWARE ENGINEERING),VERIFIKATION (SOFTWARE ENGINEERING),VERTEILTE PROGRAMMIERUNG + PARALLELE PROGRAMMIERUNG (PROGRAMMIERMETHODEN)}
}

@article{schwerhoffLightweightSupportMagic2015,
  title = {Lightweight {{Support}} for {{Magic Wands}} in an {{Automatic Verifier}}},
  author = {Schwerhoff, Malte and Summers, Alexander J.},
  editora = {Boyland, John Tang},
  editoratype = {collaborator},
  date = {2015},
  publisher = {{ETH Zurich}},
  doi = {10.3929/ETHZ-B-000104710},
  url = {http://hdl.handle.net/20.500.11850/104710},
  urldate = {2023-05-11},
  langid = {english},
  keywords = {Automatic Verifiers,Implicit Dynamic Frames,Magic Wand,Separation Logic,Software Verification},
  file = {/Users/oeb25/Zotero/storage/ZEKZ36NZ/Schwerhoﬀ and Summers - Lightweight Support for Magic Wands in an Automati.pdf}
}

@online{silvercontributersViperprojectSilverDefinition,
  title = {Viperproject/Silver: {{Definition}} of the {{Viper}} Intermediate Verification Language.},
  author = {{Silver contributers}},
  url = {https://github.com/viperproject/silver},
  urldate = {2023-07-03},
  file = {/Users/oeb25/Zotero/storage/77K752G2/silver.html}
}

@online{thomasc.halesFormalProof,
  title = {Formal {{Proof}}},
  author = {{Thomas C. Hales}},
  url = {https://www.maths.ed.ac.uk/~v1ranick/papers/hales2.pdf},
  urldate = {2022-03-10},
  file = {/Users/oeb25/Zotero/storage/V6JMIWFZ/hales2.pdf}
}

@article{vansteenBriefIntroductionDistributed2016,
  title = {A Brief Introduction to Distributed Systems},
  author = {family=Steen, given=Maarten, prefix=van, useprefix=true and Tanenbaum, Andrew S.},
  date = {2016-10},
  journaltitle = {Computing},
  shortjournal = {Computing},
  volume = {98},
  number = {10},
  pages = {967--1009},
  issn = {0010-485X, 1436-5057},
  doi = {10.1007/s00607-016-0508-7},
  url = {http://link.springer.com/10.1007/s00607-016-0508-7},
  urldate = {2022-01-21},
  langid = {english},
  keywords = {Distributed Systems},
  file = {/Users/oeb25/Zotero/storage/MN8PW5JF/van Steen and Tanenbaum - 2016 - A brief introduction to distributed systems.pdf}
}

@software{viperserver,
  title = {Viperproject/Viperserver},
  author = {Arquint, Linard and Ter-Gabrielyan, Arshavir},
  editora = {{ViperServer Contributers}},
  editoratype = {collaborator},
  date = {2023-03-24T01:19:52Z},
  origdate = {2020-02-20T10:50:51Z},
  url = {https://github.com/viperproject/viperserver},
  urldate = {2023-07-10},
  abstract = {HTTP server that manages verification requests to different tools from the Viper tool stack.},
  organization = {{Viper Project}},
  keywords = {verification,viper}
}

@book{winskelFormalSemanticsProgramming1993,
  title = {The {{Formal Semantics}} of {{Programming Languages}}: {{An Introduction}}},
  shorttitle = {The {{Formal Semantics}} of {{Programming Languages}}},
  author = {Winskel, Glynn},
  date = {1993-02-05},
  doi = {10.7551/mitpress/3054.001.0001},
  url = {https://direct.mit.edu/books/book/4338/The-Formal-Semantics-of-Programming-LanguagesAn},
  urldate = {2023-06-20},
  abstract = {The Formal Semantics of Programming Languages provides the basic mathematical techniques necessary for those who are beginning a study of the semantics and logi},
  langid = {english},
  file = {/Users/oeb25/Zotero/storage/M2W6QEI2/Winskel - 1993 - The Formal Semantics of Programming Languages An .pdf;/Users/oeb25/Zotero/storage/DHN8C9W7/The-Formal-Semantics-of-Programming-LanguagesAn.html}
}

@report{woodruffCHERIRISCCapability,
  title = {{{CHERI}}: {{A RISC}} Capability Machine for Practical Memory Safety},
  shorttitle = {{{CHERI}}},
  author = {Woodruff, Jonathan D.},
  pages = {112 pages},
  institution = {{Computer Laboratory, University of Cambridge}},
  doi = {10.48456/TR-858},
  url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-858.html},
  urldate = {2023-05-15},
  abstract = {This work presents CHERI, a practical extension of the 64-bit MIPS instruction set to support capabilities for fine-grained memory protection. Traditional paged memory protection has proved inadequate in the face of escalating security threats and proposed solutions include fine-grained protection tables (Mondrian Memory Protection) and hardware fat-pointer protection (Hardbound). These have emphasised transparent protection for C executables but have lacked flexibility and practicality. Intel's recent memory protection extensions (iMPX) attempt to adopt some of these ideas and are flexible and optional but lack the strict correctness of these proposals. Capability addressing has been the classical solution to efficient and strong memory protection but it has been thought to be incompatible with common instruction sets and also with modern program structure which uses a flat memory space with global pointers. CHERI is a fusion of capabilities with a paged flat memory producing a program-managed fat pointer capability model. This protection mechanism scales from application sandboxing to efficient byte-level memory safety with per-pointer permissions. I present an extension to the 64-bit MIPS architecture on FPGA that runs standard FreeBSD and supports self-segmenting applications in user space. Unlike other recent proposals, the CHERI implementation is open-source and of sufficient quality to support software development as well as community extension of this work. I compare with published memory safety mechanisms and demonstrate competitive performance while providing assurance and greater flexibility with simpler hardware requirements.},
  file = {/Users/oeb25/Zotero/storage/4VT3KSHI/Woodruff - CHERI A RISC capability machine for practical mem.pdf}
}
